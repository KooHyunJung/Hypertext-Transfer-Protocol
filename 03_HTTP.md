## 03 HTTP 기본 ##
- [01 모든 것이 HTTP](#1)
- [02 클라이언트 서버 구조](#2)
- [03 Stateful, Stateless](#3)
- [04 비 연결성(connectionless)](#4)
- [05 HTTP 메시지](#5)

---

<a name="1"></a>
## 01 모든 것이 HTTP ##
### HTTP (Hypertext Transfer Protocol) ###

- 처음에는 링크를 통해서 연결할 수 있는 HTML을 전송하는 것으로 시작했으나, 지금은 HTTP 프로토콜에 담아 모든 형태의 데이터를  전송한다. 심지어 서버간에 데이터를 주고 받을 때도 HTTP 사용한다. TCP를 집접 연결하는 경우는 게임, 특수한 경우.
- **지금은 HTTP 시대!**

```
< HTTP 역사 >
    - HTTP/0.9 1991년: GET 메소드만 지원, HTTP 헤더 X 
    - HTTP/1.0 1996년: 메서드, 헤더 추가
    - ⭐️ HTTP/1.1 1997년: 가장 많이 사용, 현재 가장 중요한 버젼 ⭐️
    - HTTP/2 2015년: 성능 개선
    - HTTP/3 진행 중: TCP 대신에 UDP 사용, 성능 개선
```
- HTTP/1.1 스팩에 대해 공부하는 것이 중요하다. HTTP/2, HTTP/3 성능개선이 중점.

```
- 기반 프로토콜
    - TCP : HTTP/1.1, HTTP/2
    - UDP : HTTP/3
    - 현재 HTTP/1.1 주로 사용
        - HTTP/2, HTTP/3 도 점점 증가
```
- HTTP/1.1, HTTP/2는 TCP 프로토콜 위에 동작을 한다. 그런데 HTTP/3는 UDP 기반으로 개발이 되어 있다. TCP는 기본적으로 속도가 느리고 무겁다. 아예 최적화해서 새롭게 나온게 HTTP/3라고 보면 된다.
- 크롬 [검색]창에서 네트워크 > 프로토콜 확인 가능

```
- HTTP 특징 :
    - 클라이언트 서버 구조
    - 무상태 프로토콜(스테이스리스), 비연결성
    - HTTP 메시지(요청, 응답)
    - 단순함, 확장 가능
```

<a name="2"></a>
## 02 클라이언트 서버 구조 ##

    - Request Response 구조
    - 클라이언트는 서버에 요청을 보내고, 응답을 대기
    - 서버가 요청에 대한 결과를 만들어서 응답

- 클라이언트와 서버구조로 되어 있다
    - -> 클라이언트는 HTTP를 통해 서버에 요청을 보낸다. 클라이언트는 서버에서 응답이 올 때까지 무작정 대기한다. 서버가 요청에 대한 응답을 만들어서 주면 그 응답 결과를 열어서 클라이언트가 동작을 하게 된다.
        - 이는 굉장히 표면적인 흐름이지만 여기서 [클라이언트]와 [서버]를 분리하는 점이 가장 중요.
        - 복잡한 비즈니스 로직, 데이터는 [서버]에 다 포함시키고 [클라이언트]는 UI, 사용성에 집중한다. **이렇게 하면 [클라이언트]와 [서버]가 각각 독립적으로 진화할 수 있다.**


<a name="3"></a>
## 03 Stateful, Stateless ##
### 무상태 프로토콜 (Stateless) ###

    스테이스리스(Stateless)
        서버가 클라이언트 상태를 유지하지 않는다
        장점 : 서버 확장성 높음(스케일 아웃)
        단점 : 클라이언트가 추가 데이터 전송

- Stateful, Stateless 차이
    - ```Stateful 상태유지```
        - 서버가 클라이언트의 이전 상태를 보존한다. 문맥을 보존하는 것이다.
        - 이때 서버가 바뀐다면 서비스 장애가 난다. 원하는 문맥이 사라지기 때문. 문제를 해결하려면 중간에 서버가 바뀔 때마다 상태 정보를 알려줘야 서비스 장애가 일어나지 않는다.
    -  ```Stateless 무상태```
        - 중간에 서버가 바뀔지라도 중간 중간에 데이터를 던져주기 때문에 서비스 장애가 일어나지 않는다.
            - 따라서 중간에 서버를 대거 증설 가능, 클라이언트 요청이 갑자기 증가해도 서버를 대거 투입할 수 있는 것이다.
        - 무상태는 응답 서버를 쉽게 바꿀 수 있다 -> ```무한한 서버 증설 가능```

- Stateful 한계
    - 항상 같은 서버가 유지되어야 한다.
        - 문제점 : 결제를 하다가 통신하고 있던 서버1이 죽으면 처음부터 결제를 다시 진행해야 한다.
        - 해결방법 : Stateless
            - 서버1는 상태를 보관하지 않고 클라이언트 요청에 응답만 한다. 그러다 중간에 연결된 서버1이 장애가 나도 [중계서버]에서 다른 서버2를 통해 관련 응답 전달 가능하다.
                - 스케일 아웃 - 수평 확장 유지
                    - 같은 기능을 하는 서버를 증설하는데 굉장히 쉽다.(주로 이벤트 서버)

- Stateless 한계
    - 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
    - 무상태
        - ex) 로그인이 필요 없는 단순한 서비스 소개 화면
    - 상태 유지가 필요한 경우
        - ex) 로그인
            - 해결방법
            - 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
            - 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
            - 상태 유지는 최소한만 사용
    - 전송된 데이터 양이 많다. 


<a name="4"></a>
## 04 비 연결성(connectionless) ##
### 연결을 유지하는 모델 ###

    연결 유지 모델
        - TCP/IP 모델은 기본적으로 연결을 유지한다
        - TCP/IP 소켓 연결 후 요청, 응답을 주고 받는다
        - 문제점: 클라이언트 1, 2, 3 계속 연결을 유지한다. 따라서 1과 2가 놀고 있어도 연결을 계속 유지하게 되고  이렇게 되면 서버의 자원이 계속 소모되는 것이다

    연결 유지하지 않는 모델
        - TCP/IP 소켓 연결 후 요청, 응답을 주고 받은 후 바로 연결을 끊어버린다
        - 서버 입장에서는 최소한의 자원을 유지할 수 있는 장점이 있다
        - 요창할 때만 연결을 진행하는 것이다

- 비 연결성
    - HTTP는 기본이 연결을 유지하지 않는 모델 
    - 요청과 응답이 일반적으로 초 단위 이하의 빠른 속도
        - 이렇게 해야 1시간 동안 수천명이 서비스를 이용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적음
            - 웹 브라우저에서 계속 연석해서 검색 하지 않음
    - 따라서 서버 자원을 매우 효울적으로 사용할 수 있다
    - 문제점(단점) : 
        - TCP/IP 연결을 새로 맺어야 함 -> 3-way-handshake
        - 웹 브라우저 사이트로 요청하면 HTML 뿐만 아니라 자바스크립트, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드
        - 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결 
            - 예를들면, 지속연결은 [연결하고 HTML 하나받고 종료 > 연결하고 자바스크립트 받고 종료 > 연결하고 이미지, 영상 받고 종료]가 아니라, 연결하고 몇초 동안 연결을 유지하여 관련 데이터를 한번에 받고 종료한다.
        - HTTP/2, HTTP/에서 더 많은 최적화

### Stateless 기억하자! (정리) ###

    - 서버 개발자들이 어려워하는 업무
        - 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
        - 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록
        - 저녁 6:00 선착순 1000명 치킨 할인 이벤트 

- 최대한 Stateless하게 설개하는 것이 중요하다. 자유롭게 증설 서버 증설 가능하기에 수만명이 동시에 요청해도 이를 대응할 수 있다.
- 어쩔 수 없는 한에서만 상태유지하는 식으로 개발


<a name="5"></a>
## 05 HTTP 메시지 ##
### HTTP 메시지에 모든 것을 전송 ###
- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML
- 거이 모든 형태의 데이터 전송 가능
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

### HTTP 메시지 구조 ###
<img width="763" alt="스크린샷 2022-05-21 오후 6 57 23" src="https://user-images.githubusercontent.com/96563289/169646377-2ea2f850-a78b-470d-b12f-08c400eb07c5.png">

✅ **시작 라인**
- 요청 메시지 :
    - 메서드
        - 종류 : GET, POST, PUT, DELETE...
        - 서버가 수행해야 할 동작 작성
            - GET : 리소스 조회
            - POST : 요청 내역 처리
    - 요청 대상
        - ```absolute-path[?query]``` (절대경로[?쿼리])
        - 절대경로 = "/"로 시작하는 경로
        - 참고) *, http://...?x=y와 같은 다른 유형의 경로지정 방법도 있다
    - HTTP 버젼
        - HTTP/1.1, HTTP/2, HTTP/3

- 응답 메시지 :
    - ```HTTP-version``` SP ```status-code``` SP ```reason-phrass CRLF```
        - HTTP 상태 코드
            - 200 : 성공
            - 400 : 클라이언트 요청 오류
            - 500 : 서버 내부 오류
        - 이유 문구 :
            - 사람이 이해할 수 있는 짧은 상태 코드 설명 글

✅ **HTTP 헤더 용도**
- HTTP 전송에 필요한 모든 부가 정보
    - 메시지 바디 내용, 바디 크기, 압축, 인증, 요청, 클라인언트(브라우저) 정보, 서버 애플리케이션 정보, 캐시 관리 정보
- 표준 헤더가 너무 많음
- 필요시 임의의 헤더 추가 가능

✅ **HTTP 바디 용도**
- 실제 전송할 데이터 
- HTML 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터 가능


**정리**
- HTTP는 단순하다
- HTTP는 메시지도 매우 단순하기에 확장 가능하다
- ```크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술```



---
### 관련 내용 참조 ###
이미지 참조 : https://velog.io/@kimwoody/HTTP-%EA%B8%B0%EB%B3%B8

