## 03 HTTP 기본 ##
- [01 모든 것이 HTTP](#1)
- [02 클라이언트 서버 구조](#2)
- [03 Stateful, Stateless](#3)
- [04 비 연결성(connectionless)](#4)
- [05 HTTP 메시지](#5)

---

<a name="1"></a>
## 01 모든 것이 HTTP ##
### HTTP (Hypertext Transfer Protocol) ###

- 처음에는 링크를 통해서 연결할 수 있는 HTML을 전송하는 것으로 시작했으나, 지금은 HTTP 프로토콜에 담아 모든 형태의 데이터를  전송한다. 심지어 서버간에 데이터를 주고 받을 때도 HTTP 사용한다. TCP를 집접 연결하는 경우는 게임, 특수한 경우.
- **지금은 HTTP 시대!**

```
< HTTP 역사 >
    - HTTP/0.9 1991년: GET 메소드만 지원, HTTP 헤더 X 
    - HTTP/1.0 1996년: 메서드, 헤더 추가
    - ⭐️ HTTP/1.1 1997년: 가장 많이 사용, 현재 가장 중요한 버젼 ⭐️
    - HTTP/2 2015년: 성능 개선
    - HTTP/3 진행 중: TCP 대신에 UDP 사용, 성능 개선
```
- HTTP/1.1 스팩에 대해 공부하는 것이 중요하다. HTTP/2, HTTP/3 성능개선이 중점.

```
- 기반 프로토콜
    - TCP : HTTP/1.1, HTTP/2
    - UDP : HTTP/3
    - 현재 HTTP/1.1 주로 사용
        - HTTP/2, HTTP/3 도 점점 증가
```
- HTTP/1.1, HTTP/2는 TCP 프로토콜 위에 동작을 한다. 그런데 HTTP/3는 UDP 기반으로 개발이 되어 있다. TCP는 기본적으로 속도가 느리고 무겁다. 아예 최적화해서 새롭게 나온게 HTTP/3라고 보면 된다.
- 크롬 [검색]창에서 네트워크 > 프로토콜 확인 가능

```
- HTTP 특징 :
    - 클라이언트 서버 구조
    - 무상태 프로토콜(스테이스리스), 비연결성
    - HTTP 메시지(요청, 응답)
    - 단순함, 확장 가능
```

<a name="2"></a>
## 02 클라이언트 서버 구조 ##

    - Request Response 구조
    - 클라이언트는 서버에 요청을 보내고, 응답을 대기
    - 서버가 요청에 대한 결과를 만들어서 응답

- 클라이언트와 서버구조로 되어 있다
    - -> 클라이언트는 HTTP를 통해 서버에 요청을 보낸다. 클라이언트는 서버에서 응답이 올 때까지 무작정 대기한다. 서버가 요청에 대한 응답을 만들어서 주면 그 응답 결과를 열어서 클라이언트가 동작을 하게 된다.
        - 이는 굉장히 표면적인 흐름이지만 여기서 [클라이언트]와 [서버]를 분리하는 점이 가장 중요.
        - 복잡한 비즈니스 로직, 데이터는 [서버]에 다 포함시키고 [클라이언트]는 UI, 사용성에 집중한다. **이렇게 하면 [클라이언트]와 [서버]가 각각 독립적으로 진화할 수 있다.**


<a name="3"></a>
## 03 Stateful, Stateless ##
### 무상태 프로토콜 (Stateless) ###

    스테이스리스(Stateless)
        서버가 클라이언트 상태를 유지하지 않는다
        장점 : 서버 확장성 높음(스케일 아웃)
        단점 : 클라이언트가 추가 데이터 전송

- Stateful, Stateless 차이
    - ```Stateful 상태유지```
        - 서버가 클라이언트의 이전 상태를 보존한다. 문맥을 보존하는 것이다.
        - 이때 서버가 바뀐다면 서비스 장애가 난다. 원하는 문맥이 사라지기 때문. 문제를 해결하려면 중간에 서버가 바뀔 때마다 상태 정보를 알려줘야 서비스 장애가 일어나지 않는다.
    -  ```Stateless 무상태```
        - 중간에 서버가 바뀔지라도 중간 중간에 데이터를 던져주기 때문에 서비스 장애가 일어나지 않는다.
            - 따라서 중간에 서버를 대거 증설 가능, 클라이언트 요청이 갑자기 증가해도 서버를 대거 투입할 수 있는 것이다.
        - 무상태는 응답 서버를 쉽게 바꿀 수 있다 -> ```무한한 서버 증설 가능```

- Stateful 한계
    - 항상 같은 서버가 유지되어야 한다.
        - 문제점 : 결제를 하다가 통신하고 있던 서버1이 죽으면 처음부터 결제를 다시 진행해야 한다.
        - 해결방법 : Stateless
            - 서버1는 상태를 보관하지 않고 클라이언트 요청에 응답만 한다. 그러다 중간에 연결된 서버1이 장애가 나도 [중계서버]에서 다른 서버2를 통해 관련 응답 전달 가능하다.
                - 스케일 아웃 - 수평 확장 유지
                    - 같은 기능을 하는 서버를 증설하는데 굉장히 쉽다.(주로 이벤트 서버)

- Stateless 한계
    - 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
    - 무상태
        - ex) 로그인이 필요 없는 단순한 서비스 소개 화면
    - 상태 유지가 필요한 경우
        - ex) 로그인
            - 해결방법
            - 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
            - 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
            - 상태 유지는 최소한만 사용
    - 전송된 데이터 양이 많다. 


<a name="4"></a>
## 04 비 연결성(connectionless) ##
### 소제목 ###


<a name="5"></a>
## 05 HTTP 메시지 ##
### 소제목 ###


---
### 관련 내용 참조 ###