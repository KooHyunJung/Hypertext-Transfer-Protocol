## 06 HTTP 상태 코드 ##
- [01 캐시 기본 동작](#1)
- [02 검증 헤더와 조건부 요청1](#2)
- [03 검증 헤더와 조건부 요청2](#3)
- [04 캐시와 조건부 요청 헤더](#4)
- [05 프록시 캐시](#5)
- [06 캐시 무효화](#6)

---



<a name="1"></a>
## 01 캐시 기본 동작 ##

<details>
  <summary>
    <h3> 캐시와 조건부 요청 </h3>
  </summary>

### 캐시는 어떻게 동작하는가? ###
- ```캐시가 없을 때```

![스크린샷 2022-06-06 오후 10 05 32](https://user-images.githubusercontent.com/96563289/172166705-0bafc0a3-2c21-45c9-9074-3622ffc6ef9c.png)
- "클라이언트에서 [요청1]을 하면 서버에서 응답" 하게 된다. 그러면 응답 받은 이미지를 화면에 보여주게 되는데, 캐시가 없는 경우에는 두 번째 똑같은 요청을 했을 때 똑같은 행위를 반복하게 된다.

```
<캐시가 없을 때>
- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다
- 인터넷 네트워크는 매우 느리고 비싸다
- 브라우저 로딩 속도가 느리다
- 느린 사용자 경험
```

- **위의 단점을 해결하기 위해 [캐시]를 적용하면 아래와 같다**
- ```캐시를 적용했을 때```

![스크린샷 2022-06-06 오후 10 12 10](https://user-images.githubusercontent.com/96563289/172167468-1526693e-81d6-4145-a046-9cf14657f802.png)

- [요청1] 때 브라우저에 캐시를 저장한다. 캐시의 유효 시간을 적어두고 "응답 결과 캐시에 저장"한다.
- [요청2] 먼저 브라우저에서 캐시를 찾는다. 60초 안에 같은 요청을 하면 네트워크를 타지 않고 동일한 응답을 내려준다

```
<캐시 적용>
- 캐시 덕분에 "캐시 가능 시간" 동안 네트워크를 사용하지 않아도 된다
- 비싼 네트워크 사용량을 줄일 수 있다
- 브라우저 로딩 속도가 매우 빠르다
- 빠른 사용자 경험
```

- **캐시 적용하고 세번째 요청을 하면 어떻게 될까?**
- ```캐시 시간 초과```
    - [요청3] "캐시 가능 시간" 후에 요청을 하면 [요청1]과 동일하게 다시 요청해야 한다.
    - 기존 캐시를 초기화 시키고 다시 60초 유효한 상태가 된다

```
<캐시 시간 초과>
- 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다
- 이 때 다시 네트워크 다운로드가 발생한다
```

> 하지만... 시간 초과 후 요청도 [요청1]과 동일하다면... 이 과정이 너무 아깝다... 이 문제는 어떻게 해결할 수 있을까???

</details>


<a name="2"></a>
## 02 검증 헤더와 조건부 요청1 ##

<details>
  <summary>
    <h3> 캐시 유효 시간 초과 문제를 해결해 보자! </h3>
  </summary>

- 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다
    1) 서버에서 기존 데이터를 변경함 (A 이미지 -> B 이미지로 변경)
    2) 서버에서 기존 데이터를 변경하지 않음

- **"캐시 시간 초과" 해결방법은 바로!!!**
    - ```검증 헤더```
    - ```조건부 요청```

### ```검증 헤더``` 추가 ###

![스크린샷 2022-06-06 오후 10 35 12](https://user-images.githubusercontent.com/96563289/172171253-db5a38ce-f487-4855-9577-697076147a00.png)

- ```Last-Modified: UTC 표기법``` 데이터 최종 수정일을 헤더에 넣어 둔 응답을 내려준다
- 이를 캐시에 저장한다
- 시간 초과 후 [요청2]를 보낼 때, 기존 캐시에 "데이터 최종 수정일"을 넘기면 서버에서 이를 보고 판단한다. 만약 동일하면 아래 이미지럼 304 응답을 보낸다. 이 때 HTTP Body를 보내지 않는다.
    - 이처럼 [헤더]만 보내면 네트워크 부화가 학 줄어든다!

![스크린샷 2022-06-06 오후 10 43 34](https://user-images.githubusercontent.com/96563289/172172761-7e12381c-21ec-4188-95f9-51670a78719d.png)

```
<검증 헤더와 조건부 요청>
- 캐시 유효 시간 초과해도 서버 데이커가 생신되지 않으면 "304 Not Modified + 헤더 메타 정보만 응답(바디 X)"
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신, 캐시에 저장되어 있는 데이터 재활용한다
- 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 되기에 매우 실용적인 해결책이다
```

</details>

<a name="3"></a>
## 03 검증 헤더와 조건부 요청2 ##

<details>
  <summary>
    <h3> 검증 헤더와 조건부 요청 </h3>
  </summary>

### 검증 헤더와 조건부 요청 ###
- **검증 헤더**
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - ```Last-Modified, ETag```
- **조건부 요청 헤더**
  - 검증 헤더로 조건에 따른 분기
  - ```If-Modified-Since: Last-Modified``` 사용
  - ```If-None-Match: ETag``` 사용
  - 조건이 만족하면 ```200 OK```
  - 조건이 만족하지 않으면 ```304 Not Modified```

<details>
  <summary>
    <h3> 검증 헤더와 조건부 요청 (예시) </h3>
  </summary>

- ```If-Modified-Since: ``` 이후에 데이터가 수정되었으면?
  - **데이터 미변경**
    - 캐시: 2020년 06월 07일 11:10:00 🆚 2020년 06월 07일 11:10:00 (-> 동일)
    - ```304 Not Modified```, 헤더 데이터만 전송(BODY 미포함)
    - 전송 용량 0.1M(헤더 0.1M, 바디 1.0M)
  - **데이터 변경**
    - 캐시: 2020년 06월 07일 11:10:00 🆚 서버: 2022년 06월 07일 **12:00:00**
    - ```200 OK```, 모든 데이터 전송(BODY 포함)
    - 전송 용량 1.1M(헤더 0.1M, 바디 1.0M)
</details>

> 캐시 시간 초과 단점을 보안한 [검증 헤더와 조건부 요청] 방법이 과연 장점만 있을까???

###  검증 헤더와 조건부 요청 Last-Modified 단점 ###
- ```If-Modified-Since: Last-Modified``` 단점
  - 1) 1초 미만(0.X초) 단위로 캐시 조정 불가능
  - 2) [날짜 기반의 로직] 사용
    - 데이터 수정 날짜는 다르지만, "같은 데이터"를 수정해서 데이터가 동일해도 [날짜 기반 로직]임으로 다시 전체 데이터를 다운로드 받는다
    - **‼️ 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 어떻게 할까???**
      - (스페이스 또는 주석처럼 크게 영향이 없는 변경에서 캐시를 유지)

### ✅ 서버에서 별도의 캐시 로직을 관리하는 방법 ###
- ```ETag, If-None-Match``` 사용
- ```ETag(Entity Tag)```
  - 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
    - 예) ETag: "v1.0", ETag: "a2dkfhddl22"
  - 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash 다시 생성)
    - 예) ETag: "aaaa" -> ETag: "bbbb"
  - 따라서!! **클라이언트에서 ETag만 보내서 서버와 같으면 유지. 다르면 다시 받기!**

  ![스크린샷 2022-06-07 오전 11 39 36](https://user-images.githubusercontent.com/96563289/172284079-df92a1f1-e4bf-43ee-8475-b6e416a4270f.png)

  - ETag 특징 : **캐시 제어 로직을 서버에서 완전히 관리**
  - 때문에 클라이언트 입장에서 ETag 완전한 블랙박스이다 👍
  - 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)
    - ETag 적용 예) 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신

</details>

<a name="4"></a>
## 04 캐시와 조건부 요청 헤더 ##

<details>
  <summary>
    <h3> 캐시와 조건부 요청 헤더 </h3>
  </summary>
</details>

<a name="5"></a>
## 05 프록시 캐시 ##

<details>
  <summary>
    <h3> 프록시 캐시 </h3>
  </summary>
</details>

<a name="6"></a>
## 06 캐시 무효화 ##

<details>
  <summary>
    <h3> 캐시 무효 </h3>
  </summary>
</details>

---
### 관련 내용 참조 ###
- 

### 학습 메모 ###
- 