## 06 HTTP 상태 코드 ##
- [01 캐시 기본 동작](#1)
- [02 검증 헤더와 조건부 요청1](#2)
- [03 검증 헤더와 조건부 요청2](#3)
- [04 캐시와 조건부 요청 헤더](#4)
- [05 프록시 캐시](#5)
- [06 캐시 무효화](#6)

---



<a name="1"></a>
## 01 캐시 기본 동작 ##

<details>
  <summary>
    <h3> 캐시와 조건부 요청 </h3>
  </summary>

### 캐시는 어떻게 동작하는가? ###
- ```캐시가 없을 때```

![스크린샷 2022-06-06 오후 10 05 32](https://user-images.githubusercontent.com/96563289/172166705-0bafc0a3-2c21-45c9-9074-3622ffc6ef9c.png)
- "클라이언트에서 [요청1]을 하면 서버에서 응답" 하게 된다. 그러면 응답 받은 이미지를 화면에 보여주게 되는데, 캐시가 없는 경우에는 두 번째 똑같은 요청을 했을 때 똑같은 행위를 반복하게 된다.

```
<캐시가 없을 때>
- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다
- 인터넷 네트워크는 매우 느리고 비싸다
- 브라우저 로딩 속도가 느리다
- 느린 사용자 경험
```

- **위의 단점을 해결하기 위해 [캐시]를 적용하면 아래와 같다**
- ```캐시를 적용했을 때```

![스크린샷 2022-06-06 오후 10 12 10](https://user-images.githubusercontent.com/96563289/172167468-1526693e-81d6-4145-a046-9cf14657f802.png)

- [요청1] 때 브라우저에 캐시를 저장한다. 캐시의 유효 시간을 적어두고 "응답 결과 캐시에 저장"한다.
- [요청2] 먼저 브라우저에서 캐시를 찾는다. 60초 안에 같은 요청을 하면 네트워크를 타지 않고 동일한 응답을 내려준다

```
<캐시 적용>
- 캐시 덕분에 "캐시 가능 시간" 동안 네트워크를 사용하지 않아도 된다
- 비싼 네트워크 사용량을 줄일 수 있다
- 브라우저 로딩 속도가 매우 빠르다
- 빠른 사용자 경험
```

- **캐시 적용하고 세번째 요청을 하면 어떻게 될까?**
- ```캐시 시간 초과```
    - [요청3] "캐시 가능 시간" 후에 요청을 하면 [요청1]과 동일하게 다시 요청해야 한다.
    - 기존 캐시를 초기화 시키고 다시 60초 유효한 상태가 된다

```
<캐시 시간 초과>
- 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다
- 이 때 다시 네트워크 다운로드가 발생한다
```

> 하지만... 시간 초과 후 요청도 [요청1]과 동일하다면... 이 과정이 너무 아깝다... 이 문제는 어떻게 해결할 수 있을까???

</details>


<a name="2"></a>
## 02 검증 헤더와 조건부 요청1 ##

<details>
  <summary>
    <h3> 캐시 유효 시간 초과 문제를 해결해 보자! </h3>
  </summary>

- 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다
    1) 서버에서 기존 데이터를 변경함 (A 이미지 -> B 이미지로 변경)
    2) 서버에서 기존 데이터를 변경하지 않음

- **"캐시 시간 초과" 해결방법은 바로!!!**
    - ```검증 헤더```
    - ```조건부 요청```

### ```검증 헤더``` 추가 ###

![스크린샷 2022-06-06 오후 10 35 12](https://user-images.githubusercontent.com/96563289/172171253-db5a38ce-f487-4855-9577-697076147a00.png)

- ```Last-Modified: UTC 표기법``` 데이터 최종 수정일을 헤더에 넣어 둔 응답을 내려준다
- 이를 캐시에 저장한다
- 시간 초과 후 [요청2]를 보낼 때, 기존 캐시에 "데이터 최종 수정일"을 넘기면 서버에서 이를 보고 판단한다. 만약 동일하면 아래 이미지럼 304 응답을 보낸다. 이 때 HTTP Body를 보내지 않는다.
    - 이처럼 [헤더]만 보내면 네트워크 부화가 학 줄어든다!

![스크린샷 2022-06-06 오후 10 43 34](https://user-images.githubusercontent.com/96563289/172172761-7e12381c-21ec-4188-95f9-51670a78719d.png)

```
<검증 헤더와 조건부 요청>
- 캐시 유효 시간 초과해도 서버 데이커가 생신되지 않으면 "304 Not Modified + 헤더 메타 정보만 응답(바디 X)"
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신, 캐시에 저장되어 있는 데이터 재활용한다
- 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 되기에 매우 실용적인 해결책이다
```

</details>

<a name="3"></a>
## 03 검증 헤더와 조건부 요청2 ##

<details>
  <summary>
    <h3> 검증 헤더와 조건부 요청 </h3>
  </summary>

### 검증 헤더와 조건부 요청 ###
- **검증 헤더**
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - ```Last-Modified, ETag```
- **조건부 요청 헤더**
  - 검증 헤더로 조건에 따른 분기
  - ```If-Modified-Since: Last-Modified``` 사용
  - ```If-None-Match: ETag``` 사용
  - 조건이 만족하면 ```200 OK```
  - 조건이 만족하지 않으면 ```304 Not Modified```

<details>
  <summary>
    <h3> 검증 헤더와 조건부 요청 (예시) </h3>
  </summary>

- ```If-Modified-Since: ``` 이후에 데이터가 수정되었으면?
  - **데이터 미변경**
    - 캐시: 2020년 06월 07일 11:10:00 🆚 2020년 06월 07일 11:10:00 (-> 동일)
    - ```304 Not Modified```, 헤더 데이터만 전송(BODY 미포함)
    - 전송 용량 0.1M(헤더 0.1M, 바디 1.0M)
  - **데이터 변경**
    - 캐시: 2020년 06월 07일 11:10:00 🆚 서버: 2022년 06월 07일 **12:00:00**
    - ```200 OK```, 모든 데이터 전송(BODY 포함)
    - 전송 용량 1.1M(헤더 0.1M, 바디 1.0M)
</details>

> 캐시 시간 초과 단점을 보안한 [검증 헤더와 조건부 요청] 방법이 과연 장점만 있을까???

###  검증 헤더와 조건부 요청 Last-Modified 단점 ###
- ```If-Modified-Since: Last-Modified``` 단점
  - 1) 1초 미만(0.X초) 단위로 캐시 조정 불가능
  - 2) [날짜 기반의 로직] 사용
    - 데이터 수정 날짜는 다르지만, "같은 데이터"를 수정해서 데이터가 동일해도 [날짜 기반 로직]임으로 다시 전체 데이터를 다운로드 받는다
    - **‼️ 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 어떻게 할까???**
      - (스페이스 또는 주석처럼 크게 영향이 없는 변경에서 캐시를 유지)

### ✅ 서버에서 별도의 캐시 로직을 관리하는 방법 ###
- ```ETag, If-None-Match``` 사용
- ```ETag(Entity Tag)```
  - 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
    - 예) ETag: "v1.0", ETag: "a2dkfhddl22"
  - 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash 다시 생성)
    - 예) ETag: "aaaa" -> ETag: "bbbb"
  - 따라서!! **클라이언트에서 ETag만 보내서 서버와 같으면 유지. 다르면 다시 받기!**

  ![스크린샷 2022-06-07 오전 11 39 36](https://user-images.githubusercontent.com/96563289/172284079-df92a1f1-e4bf-43ee-8475-b6e416a4270f.png)

  - ETag 특징 : **캐시 제어 로직을 서버에서 완전히 관리**
  - 때문에 클라이언트 입장에서 ETag 완전한 블랙박스이다 👍
  - 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)
    - ETag 적용 예) 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신

</details>

<a name="4"></a>
## 04 캐시와 조건부 요청 헤더 ##

### 캐시 제어 헤더 ###
1. Cache-Control: 캐시 제어
2. Pragma: 캐시 제어(하위 호환)
3. Expires: 캐시 유효 기간(하위 호환)

<details>
  <summary>
    <h3> 캐시 제어 헤더 (3가지) 대해서 </h3>
  </summary>

<details>
  <summary>
    <h3> Cache-Control </h3>
  </summary>

> 캐시 제어 헤더 3가지가 있지만 오늘날 Cache-Control로 거이 모든 걸 한다

- ```Cache-Control: max-age```
  - 캐시 유효 시간, 초 단위로 입력할 수 있다(보통 유효시간을 길게 잡는다)
- ```Cache-Control: no-cache```
  - 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용해야 된다.
    - [재요청] 시 "If-Modified-Since: Last-Modified" 보내는 것 처럼 항상 서버에 물어보고 사용하라는 것.
- ```Cache-Control: no-store```
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
    - 보통 캐시하면 하드디스크에 저장이 된다. 하지만 응답 캐시에 "Cache-Control: no-store" 있으면 메모리에서 사용하고 최대한 빨리 삭제한다

</details>

<details>
  <summary>
    <h3> Pragma </h3>
  </summary>

> 지금은 거이 사용하지 않는다. 하지만 하위 호환으로 필요하면 사용하기도 한다.

- ```Pragma: no-cache```
  - no-cache처럼 동작한다
- HTTP 1.0 하위 호환

</details>

<details>
  <summary>
    <h3> Expires </h3>
  </summary>

- ```expires: Mon, 01 Jan 1990 00:00:00 GMT```
- 캐시 만료일을 정확한 날짜로 지정할 수 있다(날짜지정 보다 초단위로 만료일 지정하는 방법이 훨씬 유용한 방법이다)
  - 때문에 지금은 더 유연한 ```Cache-Control: max-age``` 사용 권장한다
- HTTP 1.0 부터 사용
- ```Cache-Control: max-age```와 함께 사용하면 Expires는 무시한다

</details>

### [검증 헤더]와 [조건부 요청 헤더] 정리 ###

- **[검증 헤더 (Validator)]**
  - ```ETag:``` "v1.0", ```ETag:``` "a2dkfhddl22"
  - ```Last-Modified:``` Thu, 04 Jun 2020 07:20:30 GMT
- **[조건부 헤더] 4가지**
  - If-Match, If-None-Match: ETag 값 사용
  - If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용
</details>

<a name="5"></a>
## 05 프록시 캐시 ##

<details>
  <summary>
    <h3> 프록시 캐시 </h3>
  </summary>

> 진짜 서버!! 원 소스가 있는 서버는 "origin 서버"라고 한다. 하지만 원서버가 "미국"에 있다면 한국에서 요청하고 응답을 받기까지 굉장히 오래 걸린다. 이를 해결하기 위해 [프록시 캐시 서버]를 도입한다. 
> 한국 어딘가에 있는 [프록시 캐시 서버] 설치하고 한국에서 오는 요청은 [프록시 캐시 서버]를 거쳐서 미국에 있는 원 서버에 접근하게 된다. 
> 따라서 유튜브를 빨리 볼 수 있는 것이다. 때문에 한국 사람들이 잘 안 보는 영상을 보면 시간이 굉장히 오래 걸리고, 잘 보는 영상을 보면 굉장히 응답이 빠른 것이다. 

![스크린샷 2022-06-07 오후 1 12 00](https://user-images.githubusercontent.com/96563289/172294421-cf8aa528-19f0-46b7-b387-7a104a41eef9.png)

-  **[프록시 캐시 서버]** 는 중간에서 공용으로 사용하는 ```public 캐시```가 저장된다.

### 관련 "캐시 지시어" (기타) ###

![스크린샷 2022-06-07 오후 1 18 17](https://user-images.githubusercontent.com/96563289/172295040-08405a68-df1c-4e1d-b205-97b1adb865e7.png)

</details>

<a name="6"></a>
## 06 캐시 무효화 ##

<details>
  <summary>
    <h3> Cache-Control 확실한 캐시 무효화 응답 </h3>
  </summary>

> ❓ 캐시 적용을 안 하면 캐시 안되는 거 아닌가? 무효화 방법이 따로 필요한가?

> ❗️ 네 !!! 웹브라우저에서 GET 요청이 오면 임의로 캐시를 저장해 버린다!

> ✅ 따라서 "이 페이지는 캐시되면 안된다!" 하면 아래 내용을 전부 작성해 줘야 한다

```
Cache-Control: no-cache, no-store, must-revalidate
Pragma: no-cache
```

```Pragma: no-cache``` 이 구닥다리는 왜 쓰는가?
-> 과거 브라우저 요청이 올 수 있기 때문에 작성해 준다. (HTTP 1.0 하위 호환)

### 캐시 지시어 - 확실한 캐시 무효화

![스크린샷 2022-06-07 오후 1 27 36](https://user-images.githubusercontent.com/96563289/172296160-9366275d-07ad-45ba-9713-08e47cd27268.png)

</details>

<details>
  <summary>
    <h3> no-cache만 사용하지... 왜 "must-revalidate"가 필요한가? </h3>
  </summary>

> "no-cache", "must-revalidate" 둘 다 서버에 검증하고 사용 한다. 단 no-cache는 항상 원 서버 검증. must-revalidate는 캐시 만료 후 최초 조회 시 원 서버 검증 한다.

### no-cache 기본 동작

![스크린샷 2022-06-07 오후 4 16 17](https://user-images.githubusercontent.com/96563289/172319486-02013a19-590e-421f-b65e-8b92310c4047.png)

> no-cache 경우 원 서버에 보내야 하지만 순간 네트워크가 단절하면 프록시 데이터에 장애가 일어나면 옛 데이터를 보여주는 설정을 할 수 있다. 이렇게 설정을 하면 네트워크 장애 시 원 서버가 아닌 프록시에서 응답.

![스크린샷 2022-06-07 오후 4 16 31](https://user-images.githubusercontent.com/96563289/172319707-6f3e4052-6579-4a14-916e-f377cbd36a50.png)

> ‼️ 하지만 이렇게 하면 문제가 발생한다

> 상황 예시) 계좌이체를 하고 통장 새로고침을 했는데 네트워크 장애로 원 서버가 아닌 프록시에서 응답하게 되면 옛 통장 잔고가 보이게 된다...!

> 때문에 "must-revalidate"까지 작성해 주는 것이다

![스크린샷 2022-06-07 오후 4 17 02](https://user-images.githubusercontent.com/96563289/172319767-b99f8905-39aa-46f3-ba02-8f49ed171544.png)

> "must-revalidate"는 원 서버로 가는 네트워크 장애가 발생하면 이미지 같이 504 에러로 응답한다

</details>

---
### 관련 내용 참조 ###
- 

### 학습 메모 ###
- 